import traceback
from functools import wraps
from cachetools.keys import hashkey
from textwrap import dedent
from termcolor import colored
from .frame import AppRunnerFrame
from .debug import timing
from .collector import ShadowCollector
from .component_keys import get_component_key
from .component_base import Component
from .exceptions import Stop


class Cache:
    NotFound = object()

    def __init__(self):
        self.cache = dict()

    def put(self, key, value):
        self.cache[key] = value

    def get(self, key):
        if key not in self.cache:
            return Cache.NotFound
        return self.cache[key]

    def eject_entries_for_mutated_props(self, mutations):
        with timing("Cache ejection"):
            keys_to_eject = set()
            for key, entry in self.cache.items():
                deps = entry["deps"]
                for mutation in mutations:
                    if mutation in deps:
                        keys_to_eject.add(key)
                        break
            for key_to_eject in keys_to_eject:
                self.cache.pop(key_to_eject)


def cached_wrapper(cache_key, fn, *args, **kwargs):
    frame = AppRunnerFrame.current()

    cached_value = frame.cache_get(cache_key)

    if cached_value == Cache.NotFound:
        saved_deps = frame.deps
        fn_deps = set()
        frame.deps = fn_deps
        collector = ShadowCollector()
        frame.collector_stack.push(collector)

        # Run the function
        try:
            result = fn(*args, **kwargs)
        except Stop:
            raise
        except Exception as e:
            # If the user function raises an error we print a
            # stacktrace and stop the loop.

            # TODO: Show better stack traces that pertain to the
            # user's code, and avoid showing the pieces of the stack
            # trace from inside Hyperdiv, which can be confusing.
            tb = traceback.extract_tb(e.__traceback__)
            user_traceback = []

            # hyperdiv_dir = os.path.dirname(source_path)

            for trace in tb:
                # if not trace.filename.startswith(hyperdiv_dir):
                user_traceback.append(trace)

            message = (
                dedent("".join(traceback.format_list(user_traceback)))
                + f"{e.__class__.__name__}: {e}"
            )

            print(colored(message, "red"))

            raise Stop()

        if isinstance(result, Component):
            # TODO: If the function leaks out a component, we
            # don't want children to be added to it, because those
            # children would remain in the cached value in
            # subsequent frames. We could make this more
            # user-friendly by invalidating the cache when a child
            # is added.
            result._sealed = True

        frame.collector_stack.pop()
        frame.deps = saved_deps

        cached_value = dict(
            result=result,
            collector=collector,
            deps=fn_deps,
        )

        frame.cache_put(cache_key, cached_value)

    frame.collector_stack.internal_current()._extend(cached_value["collector"])
    frame.deps.update(cached_value["deps"])

    return cached_value["result"]


def cached(fn):
    """
    To help improve performance when building large, modular apps,
    Hyperdiv functions that generate UI components can be wrapped in
    `@cached` to avoid re-running those function calls if their read
    dependencies have not changed.

    For example:

    ```py
    @hd.cached
    def my_counter(label):
       state = hd.state(count=0)
       with hd.box(
           gap=1,
           padding=1,
           border="1px solid neutral-100",
           border_radius=1,
       ):
           hd.markdown(f"### {label}")
           hd.text(state.count)
           if hd.button("Increment").clicked:
               state.count += 1

    my_counter("Counter")
    my_counter("Counter")
    ```

    In this example. If we click the `Increment` button in the first
    counter, that first call to `my_function("Counter")` will re-run,
    because its read dependency on `button.clicked` is invalidated.
    But the second call will *not* re-run, since its read dependencies
    have not changed.

    Similarly, if we click the button in the second counter, the first
    call to `my_function("Counter")` will not rerun. Instead, the
    cached UI generated by the previous call to the function will be
    reused.
    """

    @wraps(fn)
    def wrapper(*args, **kwargs):
        call_stack_key = get_component_key()
        qualname = f"{fn.__module__}.{fn.__name__}"
        cache_key = (qualname,) + hashkey(call_stack_key, *args, **kwargs)

        return cached_wrapper(cache_key, fn, *args, **kwargs)

    return wrapper


def cached_app(app_fn):
    """
    Works like @cached but only for the top-level app function. Unlike
    @cached, it does not use a component key to generate the cache
    key, enabling the addition of helper functions `is_dirty`, `deps`,
    and `get_dirty_deps` which help AppRuntime decide when to re-run
    the user app, as well as print useful debugging info.
    """

    @wraps(app_fn)
    def wrapper():
        return cached_wrapper(make_cache_key(), app_fn)

    def make_cache_key():
        return f"{app_fn.__module__}.{app_fn.__name__}"

    def get_deps(*args, **kwargs):
        cached_value = AppRunnerFrame.current().cache_get(make_cache_key())
        if cached_value == Cache.NotFound:
            return None
        return cached_value["deps"]

    def is_dirty(*args, **kwargs):
        frame = AppRunnerFrame.current()
        deps = get_deps(*args, **kwargs)
        if deps is None:
            return True
        return frame.deps_are_dirty(deps)

    def get_dirty_deps(*args, **kwargs):
        frame = AppRunnerFrame.current()
        deps = get_deps(*args, **kwargs)
        if deps is None:
            return None
        return frame.filter_dirty_deps(deps)

    wrapper.is_dirty = is_dirty

    # Useful for debugging:
    wrapper.deps = get_deps
    wrapper.get_dirty_deps = get_dirty_deps

    return wrapper
